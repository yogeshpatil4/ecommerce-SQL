# üõí E-commerce SQL Analysis Project
## üìö Table of Contents
- [üìå Project Overview](#-Project-Overview)
- [üì¶ Dataset Used](#-datasets-used)
- [üßπ Data Cleaning Performed](#-data-cleaning-performed)
- [üîç Key Business Questions Answered](#-key-business-questions-answered)
- [üß∞ Tools Used](#-tools-used)
- [üõ†Ô∏è Skills Covered](#-skills-covered)
- [‚úÖ Conclusion](#-conclusion)

## üìå Project Overview

This SQL project focuses on analyzing an e-commerce business using structured datasets that include information about customers, products, orders, order items, and payments. The goal is to extract actionable insights using SQL, helping stakeholders understand customer behavior, product trends, payment patterns, and overall business performance.


## üì¶ Dataset Used

This project uses a collection of CSV files representing a simplified e-commerce platform. The datasets are:

- **df_Customers.csv**: Contains customer details such as customer ID, city, and state.
- **df_Orders.csv**: Includes order-specific information such as order ID, order status, purchase and approval timestamps.
- **df_OrderItems.csv**: Contains individual items within orders including product ID, price, and quantity.
- **df_Products.csv**: Lists product details including product ID, category, and product name.
- **df_Payments.csv**: Holds information about payment methods, values, and number of installments.

## üßπ Data Cleaning

To ensure accurate analysis, several data cleaning steps were performed using SQL:

- **Converted datetime columns** (`order_purchase_timestamp` and `order_approved_at`) to proper DATETIME format using `STR_TO_DATE`.
```sql
UPDATE df_orders 
SET order_purchase_timestamp = 
STR_TO_DATE(order_purchase_timestamp,'%Y-%m-%d %H:%i:%s');

ALTER TABLE df_orders MODIFY order_purchase_timestamp DATETIME;


  ```

- **Removed rows with missing approval timestamps** from the `df_orders` table.
```sql
 DELETE  FROM ecommerce.df_orders
WHERE order_approved_at="";

UPDATE df_orders SET order_approved_at=
STR_TO_DATE(order_approved_at,'%Y-%m-%d %H:%i:%s');

ALTER TABLE df_orders MODIFY order_approved_at DATETIME;
```
  
- **Deleted rows with empty product category names** from the `df_products` table.
 ```sql
DELETE FROM df_products
WHERE product_category_name="";
```
- **Removed duplicate product entries** by using a CTE and `ROW_NUMBER()` to identify and keep only the first occurrence of each `product_id`.
```sql
  WITH cte AS 
(SELECT *,ROW_NUMBER() OVER(PARTITION BY product_id ORDER BY product_id) AS rn
 FROM df_products)
DELETE FROM df_products WHERE product_id IN (SELECT product_id FROM cte WHERE rn >1)
```

These steps ensured consistent and clean data before starting the analysis.


## üîç Key Business Questions Answered
### üë• Customer & Location Analysis
-  Which cities and states generated the highest total revenue?
```sql
SELECT customer_state,customer_city,ROUND(SUM(payment_value)) total_sale FROM df_customers
JOIN df_orders ON df_customers.customer_id=df_orders.customer_id
JOIN df_payments ON df_payments.order_id=df_orders.order_id
 
GROUP BY customer_state,customer_city
ORDER BY total_sale DESC;


```
- What are the top 10 cities and states by revenue, and what is their percentage contribution to overall revenue?
```sql
 SELECT *, (ROUND(total_revenue/(SELECT SUM(payment_value)  FROM  df_payments)*100,2))  percentage_contribution FROM 
(SELECT customer_state,customer_city,ROUND(SUM(payment_value) + SUM(shipping_charges)) total_revenue FROM df_customers
JOIN df_orders ON df_customers.customer_id=df_orders.customer_id
JOIN df_payments ON df_payments.order_id=df_orders.order_id
JOIN df_orderitems ON df_orderitems.order_id=df_orders.order_id
GROUP BY customer_state,customer_city
ORDER BY total_revenue DESC LIMIT 10) T;
```
- How do customer segments based on AOV quartiles differ across cities or states?
```sql
WITH CustomerAOV AS (
SELECT 
df_Orders.customer_id,
df_Customers.customer_city,
df_Customers.customer_state,
ROUND(AVG(df_Payments.payment_value), 2)  avg_order_value
FROM df_Orders
JOIN df_Payments ON df_Orders.order_id = df_Payments.order_id
JOIN df_Customers ON df_Orders.customer_id = df_Customers.customer_id
GROUP BY 
df_Orders.customer_id,
df_Customers.customer_city,
df_Customers.customer_state
)
SELECT 
customer_id,
customer_city,
customer_state,
avg_order_value,
NTILE(4) OVER (PARTITION BY customer_state ORDER BY avg_order_value DESC)  aov_quartile
FROM CustomerAOV
ORDER BY customer_state, avg_order_value DESC;
```


### üõçÔ∏è Product & Sales Performance
- What are the top 5 most frequently purchased product categories?
```sql
 SELECT product_category_name,COUNT(df_orderitems.order_id) total_order FROM df_orders 
JOIN df_orderitems ON df_orderitems.order_id=df_orders.order_id
JOIN df_products ON df_orderitems.product_id=df_products.product_id
GROUP BY product_category_name 
ORDER BY total_order DESC LIMIT 5
;
```
-  What is the total revenue generated by each product category?
```sql
 SELECT product_category_name,ROUND(SUM(payment_value)+SUM(shipping_charges)) total_revenue FROM df_orderitems
JOIN df_products ON df_orderitems.product_id=df_products.product_id
JOIN df_payments ON df_payments.order_id=df_orderitems.order_id
GROUP BY product_category_name;
```
-  How do different product pricing tiers contribute to overall sales and revenue?
```sql
ALTER TABLE df_orderitems 
ADD pricing_tier TEXT;

UPDATE df_orderitems 
SET pricing_tier=
CASE WHEN price <1000 THEN "low tier"  
WHEN (price>=1000 AND price< 3000) THEN "medium tier" 
ELSE "high tier" 
END;
SELECT pricing_tier,ROUND(SUM(payment_value) + SUM(shipping_charges)) total_revenue,ROUND(SUM(payment_value)) total_sale FROM df_orderitems 
JOIN df_payments ON df_orderitems.order_id=df_payments.order_id
GROUP BY pricing_tier;
```
- Which products show strong seasonal demand patterns across months?
```sql
SELECT 
    DATE_FORMAT(df_orders.order_purchase_timestamp, '%Y-%m-01') AS month,
    df_orderitems.product_id,
    df_products.product_category_name,
    COUNT(df_orderitems.order_id) AS total_orders,
    SUM(df_orderitems.price) AS total_sales
FROM df_orders
JOIN df_orderitems ON df_orders.order_id = df_orderitems.order_id
JOIN df_products ON df_orderitems.product_id = df_products.product_id
GROUP BY 
    DATE_FORMAT(df_orders.order_purchase_timestamp, '%Y-%m-01'),
    df_orderitems.product_id,
    df_products.product_category_name
ORDER BY 
    month,
    total_sales DESC;

```

### Payment Insights
- How does payment method usage vary in terms of total orders, sale, and average order value?
```sql
SELECT payment_type,ROUND(SUM(payment_value)) total_sale,COUNT(df_orders.order_id) total_orders,
ROUND(AVG(payment_value)) avg_order_value

FROM df_orders 
JOIN df_payments ON df_orders.order_id=df_payments.order_id
GROUP BY payment_type;
```
-What is the total payment value collected for each number of payment installments?
```sql
SELECT payment_installments,ROUND(SUM(payment_value)) total_value FROM df_payments

GROUP BY payment_installments;
```
-  Are there any orders where the payment amount does not match the order value (underpaid or overpaid)?
```sql
WITH difference_value AS (
  SELECT 
    df_orderitems.order_id,
    ROUND(SUM(price) + SUM(shipping_charges), 2) AS expected_value,
    SUM(payment_value) AS actual_value,
    ROUND(SUM(payment_value) - (SUM(price) + SUM(shipping_charges)), 2) AS difference
  FROM df_payments
  JOIN df_orderitems ON df_payments.order_id = df_orderitems.order_id
  GROUP BY df_orderitems.order_id
)

SELECT 
  order_id,
  expected_value,
  actual_value,
  difference,
  CASE 
    WHEN difference < 0 THEN 'Underpaid'
    WHEN difference > 0 THEN 'Overpaid'
    ELSE 'Exact Payment'
  END AS payment_status
FROM difference_value
WHERE difference != 0;
```

### üìà Order & Revenue Analysis
- What is the average number of items included in a single order?
```sql
SELECT AVG(total_order) avg_product_per_order FROM (SELECT COUNT(product_id) total_order FROM df_orders 
JOIN df_orderitems ON df_orders.order_id=df_orderitems.order_id
GROUP BY df_orderitems.order_id ) t;
```
-  What is the trend in monthly revenue and number of new customers acquired?
```sql

),
NewCustomers AS (
SELECT 
DATE_FORMAT(CustomerFirstOrders.first_order_date, '%Y-%m-01')  month,
COUNT(*)  new_customers
FROM CustomerFirstOrders
GROUP BY DATE_FORMAT(CustomerFirstOrders.first_order_date, '%Y-%m-01')
)
SELECT 
MonthlyRevenue.month,
MonthlyRevenue.total_sale,
COALESCE(NewCustomers.new_customers, 0)  new_customers
FROM MonthlyRevenue
LEFT JOIN NewCustomers ON MonthlyRevenue.month = NewCustomers.month
ORDER BY MonthlyRevenue.month;
  ```
- Cumulative sales growth over time
```sql
SELECT 
DATE_FORMAT(df_Orders.order_purchase_timestamp, '%Y-%m-01')  month,
ROUND(SUM(df_Payments.payment_value))  monthly_sale,
ROUND(SUM(SUM(df_Payments.payment_value)) OVER (
ORDER BY DATE_FORMAT(df_Orders.order_purchase_timestamp, '%Y-%m-01')
))  cumulative_sale
FROM df_Orders
JOIN df_Payments ON df_Orders.order_id = df_Payments.order_id
GROUP BY DATE_FORMAT(df_Orders.order_purchase_timestamp, '%Y-%m-01')
ORDER BY month;
```

### üíé Customer Value
-  What is the customer lifetime value (CLV) for each customer based on their order?
```sql
SELECT df_customers.customer_id, SUM(payment_value) CLV FROM df_customers
JOIN df_orders ON df_customers.customer_id=df_orders.customer_id
JOIN df_payments ON df_payments.order_id=df_orders.order_id
GROUP BY df_customers.customer_id;
```
- Who are the top 10% of customers contributing to the highest revenue?
```sql
WITH CustomerRevenue AS (
SELECT 
df_Orders.customer_id,
SUM(df_Payments.payment_value)  total_spent
FROM df_Orders
JOIN df_Payments ON df_Orders.order_id = df_Payments.order_id
GROUP BY df_Orders.customer_id
),
RankedCustomers AS (
SELECT 
customer_id,
total_spent,
NTILE(10) OVER (ORDER BY total_spent DESC) AS spending_decile
FROM CustomerRevenue
)
SELECT 
customer_id,
total_spent
FROM RankedCustomers
WHERE spending_decile = 1
ORDER BY total_spent DESC;
```


## üß∞ Tools Used
- **MySQL** ‚Äì for querying and analyzing the data
  
## üõ†Ô∏è Skills Covered

- SQL Joins (INNER JOIN, LEFT JOIN)
- Aggregation Functions (`SUM`, `COUNT`, `AVG`, `MAX`, `MIN`)
- Window Functions (`RANK()`, `NTILE()`, `CUME_DIST()`, `SUM() OVER`)
- Group By and Having Clauses
- Subqueries and Common Table Expressions (CTEs)
- Date & Time Analysis (`MONTH()`, `YEAR()`, `DATEDIFF`)
- Conditional Logic using `CASE WHEN`
- Filtering and Sorting (`WHERE`, `ORDER BY`, `LIMIT`)
- Data Cleaning (handling mismatched or invalid payments)
- Customer Segmentation (based on AOV quartiles)
- Trend & Revenue Analysis

## ‚úÖ Conclusion
This project provides a comprehensive analysis of e-commerce sales and customer behavior using  SQL. The insights gained help in strategic decision-making by identifying trends, customer segments, and key revenue drivers. 
